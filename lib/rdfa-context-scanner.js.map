{"version":3,"sources":["../src/rdfa-context-scanner.js"],"names":["resolvePrefixes","rdfaAttributes","prefixes","clonedAttributes","Object","assign","prefixableRdfaKeywords","forEach","key","resolvePrefix","uri","resolve","isFullUri","isRelativeUrl","i","indexOf","id","substr","Array","isArray","map","u","includes","startsWith","RdfaContextScanner","domNode","start","end","richNode","enrichRichNodeWithRdfa","rootRdfa","calculateRdfaToTop","expandRdfaContext","context","flattenRdfaTree","getRdfaAttributes","child","rootContext","resolvedRootContext","rootPrefixes","defaultPrefixes","startNode","parentNode","node","isEmptyRdfaAttributes","push","reverse","rdfa","mergePrefixes","parentContext","parentPrefixes","nodeRdfaAttributes","resolvedRdfaAttributes","concat","preprocessNode","nodeIsLogicalBlock","processChildNode","finishChildSteps","getRdfaBlockList","createRdfaBlocksFromText","createRdfaBlocksFromTag","region","text","toTriples","isRdfaBlock","semanticNode","flatRdfaChildren","reduce","a","b","combinedChildren","combineRdfaBlocks","nodes","length","firstElement","restElements","combinedElements","newElement","pastElement","rest","combinedRichNodes","e","combinedRdfaNode","rdfaBlock","isDisplayedAsBlock","getAttribute","rdfaKeywords","split","textContent","mergedPrefixes","parts","triples","currentScope","nextScope","triple","object","datatype","predicate","subject","type","window","displayStyle","getComputedStyle","analyse"],"mappings":"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","file":"rdfa-context-scanner.js","sourcesContent":["import { get, set, warn } from './ember-object-mock';\nimport { rdfaKeywords, prefixableRdfaKeywords, defaultPrefixes } from './support/rdfa-config';\nimport { walk } from './node-walker';\n\n/**\n * Resolves the URIs in an RDFa attributes object with the correct prefix\n * based on a set of known prefixes.\n *\n * @method resolvePrefix\n *\n * @param {Object} rdfaAttributes An object of RDFa attributes\n * @param {Object} prefixes A map of known prefixes\n *\n * @return {Object} An RDFa attributes object containing resolved URIs\n */\nfunction resolvePrefixes(rdfaAttributes, prefixes) {\n  const clonedAttributes = Object.assign({}, rdfaAttributes);\n  prefixableRdfaKeywords.forEach( (key) => {\n    if (clonedAttributes[key] != null)\n      clonedAttributes[key] = resolvePrefix(clonedAttributes[key], prefixes);\n  });\n  return clonedAttributes;\n}\n\n/**\n * Resolves a given (array of) URI(s) with the correct prefix (if it's prefixed)\n * based on a set of known prefixes.\n *\n * @method resolvePrefix\n *\n * @param {string|Array} uri An (array of) URI(s) to resolve\n * @param {Object} prefixes A map of known prefixes\n *\n * @return {string} The resolved URI\n *\n * @private\n */\nfunction resolvePrefix(uri, prefixes) {\n  const resolve = (uri) => {\n    if (isFullUri(uri) || isRelativeUrl(uri)) {\n      return uri;\n    } else {\n      const i = uri.indexOf(':');\n\n      if (i < 0) { // no prefix defined. Use default.\n        if (prefixes[''] == null)\n          warn(`No default RDFa prefix defined`, { id: 'rdfa.missingPrefix' });\n        uri = prefixes[''] + uri;\n      } else {\n        const key = uri.substr(0, i);\n        if (prefixes[key] == null)\n          warn(`No RDFa prefix '${key}' defined`, { id: 'rdfa.missingPrefix' });\n        uri = prefixes[key] + uri.substr(i + 1);\n      }\n\n      return uri;\n    }\n  };\n\n  if (Array.isArray(uri)) {\n    return uri.map( u => resolve(u));\n  } else {\n    return resolve(uri);\n  }\n}\n\n/**\n * Returns whether a given URI is a full URI.\n *\n * @method isFullUri\n *\n * @param {string} uri A URI\n *\n * @return {boolean} Whether the given URI is a full URI.\n *\n * @private\n */\nfunction isFullUri(uri) {\n  return uri.includes('://');\n}\n\n/**\n * Returns whether a given URI is a relative URI.\n *\n * @method isRelativeUrl\n *\n * @param {string} uri A URI\n *\n * @return {boolean} Whether the given URI is a relative URI.\n *\n * @private\n */\nfunction isRelativeUrl(uri) {\n  return uri.startsWith('#') || uri.startsWith('/') || uri.startsWith('./') || uri.startsWith('../');\n}\n\n\n\n\n/**\n * Scanner of the RDFa context of DOM nodes\n *\n * @module editor-core\n * @class RdfaContextScanner\n * @constructor\n * @extends EmberObject\n */\nclass RdfaContextScanner {\n  /**\n   * Analyse the RDFa contexts of a specific region in a text\n   *\n   * @method analyse\n   *\n   * @param {Node} domNode Root DOM node containing the text\n   * @param {[number,number]} region Region in the text for which RDFa contexts must be calculated\n   *\n   * @return {Array} Array of contexts mapping text parts from the specified region to their RDFa context\n   *               A context element consists of:\n   *               - region: Region in the text on which the RDFa context applies\n   *               - context: RDFa context (an array of triple objects) of the region\n   *               - text: Plain text of the region\n   *\n   * @public\n   */\n  analyse(domNode, [start, end]) {\n    if (domNode == null || start < 0 || end < start)\n      return [];\n\n    const richNode = walk( domNode );\n\n    this.enrichRichNodeWithRdfa(richNode);\n    const rootRdfa = this.calculateRdfaToTop(richNode);\n    this.expandRdfaContext(richNode, rootRdfa.context, rootRdfa.prefixes);\n\n    return this.flattenRdfaTree(richNode, [start, end]);\n  }\n\n  /**\n   * Enrich a rich node recursively with its RDFa attributes\n   *\n   * @method enrichRichNodeWithRdfa\n   *\n   * @param {RichNode} richNode Rich node to enrich with its RDFa attributes\n   *\n   * @private\n  */\n  enrichRichNodeWithRdfa(richNode) {\n    const rdfaAttributes = this.getRdfaAttributes(get(richNode, 'domNode'));\n    set( richNode, 'rdfaAttributes', rdfaAttributes);\n\n    if (get(richNode, 'children')) {\n      get(richNode, 'children').forEach((child) => {\n        this.enrichRichNodeWithRdfa(child);\n      });\n    }\n  }\n\n  /**\n   * Calculate the RDFa context from a given node to the top of the document\n   *\n   * @method calculateRdfaToTop\n   *\n   * @param {RichNode} richNode Rich node to start from\n   *\n   * @return {Object} Object containing the RDFa context and prefixes uptil the given node\n   *\n   * @private\n  */\n  calculateRdfaToTop(richNode) {\n    const rootContext = [];\n    const resolvedRootContext = [];\n    let rootPrefixes = defaultPrefixes;\n\n    const startNode = get(richNode, 'domNode');\n\n    if (startNode.parentNode) { // start 1 level above the rootNode of the NodeWalker\n      for(let node = startNode.parentNode; node.parentNode; node = node.parentNode) {\n        const rdfaAttributes = this.getRdfaAttributes(node);\n        if (!this.isEmptyRdfaAttributes(rdfaAttributes)) {\n          rootContext.push(rdfaAttributes);\n        }\n      }\n\n      rootContext.reverse(); // get rdfa attributes from top to bottom\n\n      rootContext.forEach((rdfa) => {\n        rootPrefixes = this.mergePrefixes(rootPrefixes, rdfa);\n        const context = resolvePrefixes(rdfa, rootPrefixes);\n        resolvedRootContext.push(context);\n      });\n    }\n\n    return {\n      context: resolvedRootContext,\n      prefixes: rootPrefixes\n    };\n  }\n\n  /**\n   * Recursively expands the RDFa context of a rich node\n   * I.e. resolve prefixes and augment RDFa context based on the prefixes and RDFa context of its parent\n   *\n   * @method expandRdfaContext\n   *\n   * @param {RichNode} richNode Rich node to expand the RDFa from\n   * @param {Array} parentContext RDFa context of the node's parent\n   * @param {Object} parentPrefixes RDFa prefixes defined at the node's parent level\n   *\n   * @private\n  */\n  expandRdfaContext(richNode, parentContext, parentPrefixes) {\n    const nodeRdfaAttributes = get(richNode, 'rdfaAttributes');\n\n    const prefixes = this.mergePrefixes(parentPrefixes, nodeRdfaAttributes);\n    set(richNode, 'rdfaPrefixes', prefixes);\n\n    if (!this.isEmptyRdfaAttributes(nodeRdfaAttributes)) {\n      const resolvedRdfaAttributes = resolvePrefixes(nodeRdfaAttributes, prefixes);\n      set(richNode, 'rdfaContext', parentContext.concat(resolvedRdfaAttributes));\n    }\n    else {\n      set(richNode, 'rdfaContext', parentContext);\n    }\n\n    if (get(richNode, 'children')) {\n      get(richNode, 'children').forEach((child) => {\n        const context = get(richNode, 'rdfaContext');\n        const prefixes = get(richNode, 'rdfaPrefixes');\n\n        this.expandRdfaContext(child, context, prefixes);\n      });\n    }\n  }\n\n  /**\n   * Flatten and reduce a rich node RDFa tree to an array of rich leaf nodes.\n   * Only the text nodes falling in a specified region are returned.\n   *\n   * It is the goal to yield a flattened tree of RDFa statements.\n   * Combining as many of them as possible.  Some examples on how we\n   * intend to combine nodes will explain the intent better than a\n   * long description.  The following cases represent a DOM tree.  The\n   * o represents a tag which doesn't contain semantic content and\n   * which in itself isn't rendered as a block.  The l represents a\n   * logical block, these are blocks which render as a visually\n   * separate block in html or which contain semantic content.  When\n   * moving upward, we want to combine these nodes in order.  When\n   * combining the nodes, we represent a non-mergeable logical block\n   * by putting parens around it.\n   *\n   * For the two examples below, we explain the logic under the\n   * drawing.\n   *\n   *\n   *  1:        o      <-  (l) (oo) o (l)\n   *           / \\\n   *  2:      l   o    <-  l = (l) (oo)  o = o l\n   *         /|\\  |\\\n   *  3:    l o o o l\n   *\n   *      -> l oo o l <-\n   *\n   * At the lowest level of nodes (3), we notice there's a logical\n   * block, followed by two inline blocks.  The two inline blocks can\n   * be combined.  Moving one level up (2), we see that these three\n   * blocks are composed within a logical block.  Hence we can't\n   * further combine the (oo) statement further up the hierarchy.\n   * Moving to the right, we see an o and an l, which can't be further\n   * combined.\n   *\n   *  -> (l) (o o) o l <-\n   *\n   *  1:        o      <-  (l) ooo (l)\n   *           / \\\n   *  2:      o   o    <-  l = (l) oo   o = o (l)\n   *         /|\\  |\\\n   *  3:    l o o o l\n   *\n   *      -> l ooo l <-\n   *\n   * This case is different from the previous case.  On level 3, in\n   * the left, we combine l o o to represent (l) oo.  The two\n   * non-logical blocks can be combined.  As we move these to a level\n   * up (2), we're still left with one logical block, and two\n   * non-logical blocks.  The right of level 3 consists of o l.  These\n   * too are stored in a non-logical block.  Hence we can combine them\n   * to represent o (l).  Combining further at the top level (1), we\n   * can combine all the three o as non of them is a logical block.\n   * Because level 1 itself isn't a logical block either, we don't put\n   * them between parens.  Hence, we end up with the blocks l ooo l.\n   *\n   * @method flattenRdfaTree\n   *\n   * @param {RichNode} richNode Rich node to flatten\n   * @param {[number,number]} region Region in the text for which RDFa nodes must be returned\n   *\n   * @return {Array} Array of rich leaf text nodes falling in a specified region\n   *\n   * @private\n   */\n  flattenRdfaTree(richNode, [start, end]) {\n    // TODO take [start, end] argumentns into account\n\n    // ran before processing the current node\n    const preprocessNode = (richNode) => {\n      // does this node represent a logical block of content?\n      set(richNode, 'isLogicalBlock', this.nodeIsLogicalBlock( richNode ));\n    };\n\n    // ran when processing a single child node\n    const processChildNode = (node) => {\n      this.flattenRdfaTree( node, [ start, end ] );\n    };\n\n    // ran when we're finished processing all child nodes\n    const finishChildSteps = (node) => {\n      set( node, 'rdfaBlocks', this.getRdfaBlockList( node ) );\n    };\n\n    preprocessNode(richNode);\n    (get(richNode, 'children') || []).map( (node) => processChildNode(node) );\n    finishChildSteps( richNode );\n\n    return get(richNode, 'rdfaBlocks');\n  }\n\n  /**\n   * Get an array of (combined) RDFa nodes for the supplied richNode.\n   * Takes into account the properties of the richNode, and the\n   * previously calculated rdfaNodeList of the children.\n   *\n   * @method getRdfaNodeList\n   *\n   * @param {RichNode} richNode The node for which to return the rdfaNodeList.\n   *\n   * @return {[RdfaBlock]} Array of rdfaBlock items.\n   *\n   * @private\n   */\n  getRdfaBlockList( richNode ){\n    switch( get( richNode, 'type' ) ){\n    case \"text\":\n      return this.createRdfaBlocksFromText( richNode );\n    case \"tag\":\n      return this.createRdfaBlocksFromTag( richNode );\n    default:\n      return [];\n    }\n  }\n\n  /**\n   * Returns an array of rdfaBlock items for the supplied richNode,\n   * assuming that is a text node.\n   *\n   * @method createRdfaBlocksFromText\n   *\n   * @param {RichNode} richNode The text node for which to return the\n   * rdfa blocks.\n   *\n   * @return {[RdfaBlock]} Array of rdfaBlock items.\n   *\n   * @private\n   */\n  createRdfaBlocksFromText( richNode ){\n    return [{\n      region: richNode.region(),\n      text: get(richNode, 'text'),\n      context: this.toTriples(get(richNode, 'rdfaContext')),\n      richNode: [richNode],\n      isRdfaBlock: get( richNode, 'isLogicalBlock' ),\n      semanticNode: ( get( richNode, 'isLogicalBlock' ) && richNode )\n    }];\n  }\n\n  /**\n   * Returns an array of rdfaBlock items for the supplied richNode,\n   * assuming that is a tag node.\n   *\n   * The idea is to first get the rdfaBlocks from each of our children\n   * and put them in a flat list.  We only need to check the first and\n   * last children for combination, but we're lazy and try to combine\n   * each of them.  In step three we clone this list, so we don't\n   * overwrite what was previously used (handy for debugging).  Then\n   * we possible overwrite the isRdfaBlock property, based on the\n   * property of our own richNode.  If we are an rdfaBlock, none of\n   * our children is still allowed to be combined after we ran the\n   * combinator.\n   *\n   * @method createRdfaBlocksFromTag\n   *\n   * @param {RichNode} richNode RichNode for which the rdfaBlock items\n   * will be returned.\n   *\n   * @return {[RdfaBlock]} Array of rdfaBlock items for this tag.\n   *\n   * @private\n   */\n  createRdfaBlocksFromTag( richNode ){\n    // flatten our children\n    const flatRdfaChildren =\n          (get(richNode, 'children') || [])\n          .map( (child) => get( child, 'rdfaBlocks' ) )\n          .reduce( (a,b) => a.concat(b), []);\n\n    // map & combine children when possible\n    const combinedChildren = this.combineRdfaBlocks( flatRdfaChildren );\n\n    // clone children\n    // const clonedChildren = combinedChildren.map( this.shallowClone );\n\n    // override isRdfaBlock on each child, based on current node\n    // set ourselves as the current first richNode in the blocks's rich nodes\n    if( get( richNode, 'isLogicalBlock' ) )\n      combinedChildren.forEach( (child) => {\n        set( child, 'isRdfaBlock', true );\n        if ( ! get( child, 'semanticNode' ) )\n          set( child, 'semanticNode', richNode );\n      });\n\n    // return new map\n    return combinedChildren;\n  }\n\n  /**\n   * Combines an array of rdfa blocks based on their properties.\n   *\n   * @method combineRdfaBlocks\n   *\n   * @param {[RichNode]} nodes Set of rich nodes for which we'll\n   * combine the rdfaBlocks.\n   *\n   * @return {[RdfaBlock]} Array of rdfaBlocks after the combineable\n   * ones were combined.\n   *\n   * @private\n   */\n  combineRdfaBlocks( nodes ){\n    if( nodes.length <= 1 ) {\n      return nodes;\n    } else {\n      // walk front-to back, build result in reverse order\n      let firstElement, restElements;\n      [ firstElement, ...restElements ] = nodes;\n      const combinedElements =\n            restElements.reduce( ([pastElement, ...rest], newElement) => {\n              if( get(pastElement, 'isRdfaBlock') || get(newElement, 'isRdfaBlock') )\n                return [newElement, pastElement, ...rest];\n              else {\n                let [ start, end ] = get( pastElement, 'region' );\n                const combinedRichNodes = [ pastElement, newElement ]\n                      .map( (e) => get( e, 'richNode') )\n                      .reduce( (a,b) => a.concat(b), [] );\n\n                const combinedRdfaNode = {\n                  region: [ start, end ],\n                  text: get(pastElement, 'text').concat( get(newElement, 'text' ) ),\n                  context: get( pastElement, 'context' ),  // pick any of the two\n                  richNode: combinedRichNodes,\n                  isRdfaBlock: false // these two nodes are text nodes\n                };\n                return [combinedRdfaNode, ...rest];\n              }\n            }, [firstElement] );\n      // reverse generated array\n      combinedElements.reverse();\n      return combinedElements;\n    }\n  }\n\n  /**\n   * Returns a shallow clone of the supplied object\n   *\n   * @param {Object} rdfaBlock The object to clone\n   *\n   * @return {Object} A shallow clone of the supplied object.\n   *\n   * @private\n   */\n  shallowClone( rdfaBlock ){\n    return Object.assign( {}, rdfaBlock );\n  }\n\n  /**\n   * Returns truethy if the supplied node represents a logical block.\n   * We expect to override this as we discover new cases.  In general\n   * we check whether there's RDFa defined on the element and/or\n   * whether it is a block when rendered in the browser with the\n   * current style.\n   *\n   * @method nodeIsLogicalBlock\n   *\n   * @param {RichNode} richNode Rich node which will be checked\n   *\n   * @return {boolean} True iff the node is a logical block\n   *\n   * @private\n   */\n  nodeIsLogicalBlock(richNode) {\n    // non-tags are never blocks\n    if( get(richNode, 'type') != \"tag\" ) {\n      return false;\n    } else {\n      if( ! this.isEmptyRdfaAttributes( get(richNode, 'rdfaAttributes') )\n          || this.isDisplayedAsBlock( richNode ) )\n        return true;\n      else\n        return false;\n    }\n  }\n\n  /**\n   * Get the RDFa attributes of a DOM node\n   *\n   * @method getRdfaAttributes\n   *\n   * @param {Node} domNode DOM node to get the RDFa attributes from\n   *\n   * @return {Object} Map of RDFa attributes key-value pairs\n   *\n   * @private\n   */\n  getRdfaAttributes(domNode) {\n    const rdfaAttributes = {};\n\n    if (domNode && domNode.getAttribute)\n    {\n      rdfaKeywords.forEach(function(key) {\n        rdfaAttributes[key] = domNode.getAttribute(key);\n      });\n\n      if (rdfaAttributes['typeof'] != null)\n        rdfaAttributes['typeof'] = rdfaAttributes['typeof'].split(' ');\n    }\n\n    rdfaAttributes['text'] = domNode.textContent;\n\n    return rdfaAttributes;\n  }\n\n  /**\n   * Returns whether a given RDFa attributes object is empty. This means no RDFa statement is set.\n   *\n   * @method isEmptyRdfaAttributes\n   *\n   * @param {Object} rdfaAttributes An RDFa attributes object\n   *\n   * @return {boolean} Whether the given RDFa attributes object is empty.\n   *\n   * @private\n   */\n  isEmptyRdfaAttributes(rdfaAttributes) {\n    return rdfaKeywords\n      .map(function (key) { return rdfaAttributes[key] == null; })\n      .reduce(function(a, b) { return a && b; });\n  }\n\n  /**\n   * Create a map of RDFa prefixes by merging an existing map of RDFa prefixes with new RDFa attributes\n   *\n   * @method mergePrefixes\n   *\n   * @param {Object} prefixes An map of RDFa prefixes\n   * @param {Object} rdfAttributes An RDFa attributes object\n   *\n   * @return {Object} An new map of RDFa prefixes\n   *\n   * @private\n   */\n  mergePrefixes(prefixes, rdfaAttributes) {\n    const mergedPrefixes = Object.assign({}, prefixes);\n\n    if (rdfaAttributes['vocab'] != null) {\n      mergedPrefixes[''] = rdfaAttributes['vocab'];\n    }\n    if (rdfaAttributes['prefix'] != null) {\n      const parts = rdfaAttributes['prefix'].split(\" \");\n      for(let i = 0; i < parts.length; i = i + 2) {\n        const key = parts[i].substr(0, parts[i].length - 1);\n        mergedPrefixes[key] = parts[i + 1];\n      }\n    }\n\n    return mergedPrefixes;\n  }\n\n  /**\n   * Transforms an array of RDFa attribute objects to an array of triples.\n   * A triple is an object consisting of a subject, predicate and object.\n   *\n   * @method toTriples\n   *\n   * @param {Array} contexts An array of RDFa attribute objects\n   *\n   * @returns {Array} An array of triple objects\n   *\n   * @private\n   */\n  toTriples(rdfaAttributes) {\n    const triples = [];\n\n    let currentScope = null;\n\n    rdfaAttributes.forEach(function(rdfa) {\n      let nextScope = null;\n\n      const triple = {};\n\n      if (rdfa['about'] != null)\n        currentScope = rdfa['about'];\n\n      if (rdfa['content'] != null)\n        triple.object = rdfa['content'];\n      if (rdfa['datatype'] != null)\n        triple.datatype = rdfa['datatype'];\n\n      if (rdfa['property'] != null) {\n        triple.predicate = rdfa['property'];\n\n        if (rdfa['href'] != null)\n          triple.object = rdfa['href'];\n\n        if (rdfa['resource'] != null) {\n          triple.object = rdfa['resource'];\n          nextScope = rdfa['resource'];\n        }\n\n        if (triple.object == null)\n          triple.object = rdfa.text;\n      } else {\n        if (rdfa['resource'] != null)\n          currentScope = rdfa['resource'];\n      }\n\n      triple.subject = currentScope;\n      if (triple.predicate != null) {\n        triples.push(triple);\n      }\n\n      if (rdfa['typeof'] != null) {\n        rdfa['typeof'].forEach(function(type) {\n          triples.push({\n            subject: rdfa['resource'], // create a blank node if resource == null\n            predicate: 'a',\n            object: type\n          });\n        });\n      }\n\n      // TODO: add support for 'rel' keyword: https://www.w3.org/TR/rdfa-primer/#alternative-for-setting-the-property-rel\n      // TODO: add support for 'src' keyword\n\n      // nextScope becomes the subject at the next level\n      if (nextScope != null) {\n        currentScope = nextScope;\n      }\n    });\n\n    return triples;\n  }\n\n  /**\n   * Whether an element is displayed as a block\n   *\n   * @method isDisplayedAsBlock\n   *\n   * @param {RichNode} richNode Node to validate\n   *\n   * @return {boolean} true iff the element is displayed as a block\n   *\n   * @private\n   */\n  isDisplayedAsBlock(richNode) {\n    if( get( richNode, 'type' ) != 'tag' )\n      return false;\n\n    if( typeof window !== \"undefined\" ) {\n      const domNode = get(richNode, 'domNode');\n      const displayStyle = window.getComputedStyle(domNode)['display'];\n      return displayStyle == 'block' || displayStyle == 'list-item';\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Shorthand form for creating a new RdfaContextScanner and analysing the supplied node with it.\n *\n * @method analyse\n * \n * @param {Node} node Node to be analysed\n *\n * @return {[RichNode]} RichNodes containing the analysed node\n */\nfunction analyse(node){\n  return (new RdfaContextScanner()).analyse( node, [ 0, 1000000] );\n}\n\nexport default RdfaContextScanner;\nexport { analyse , resolvePrefixes };\n"]}